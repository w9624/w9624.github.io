<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringDataREST]]></title>
    <url>%2F2018%2F08%2F06%2FSpringDataREST%2F</url>
    <content type="text"><![CDATA[Spring Data REST (SprringBoot)REST即表述性状态传递（Representational State Transfer）：将资源的状态以最合适的形式在客户端和服务器之间转移。使用上可以简单的理解为：Http定义操作，URL确定资源，从而完成对资源的处理Spring Data REST 支持将Spring Data JPA等的repository自动转换为REST 两种配置方式： 继承RepositoryRestMvcConfigration 12345678910111213Configurationpublic class RestConfig&#123; @Bean public RepositoryRestConfigurer repositoryRestConfigurer() &#123; return new RepositoryRestConfigurerAdapter() &#123; @Override public void configureRepositoryRestConfiguration(RepositoryRestConfiguration config) &#123; config.setBasePath("/api"); //配置其他属性 &#125; &#125;; &#125;&#125; 修改application.properties 1234567891011121314151617181920#暴漏资源的根路径spring.data.rest.base-path=/data#每页默认的sizespring.data.rest.default-page-size=2#公开所有公用repository接口, 但考虑 @Repository注解 #spring.data.rest.detection-strategy=default #spring.data.rest.enable-enum-translation= ## Enable enum value translation via the Spring Data REST default resource bundle.#spring.data.rest.limit-param-name=## Name of the URL query string parameter that indicates how many results to return at once.#spring.data.rest.max-page-size= 2## Maximum size of pages.#spring.data.rest.page-param-name= ## Name of the URL query string parameter that indicates what page to return.#spring.data.rest.return-body-on-create= true## Return a response body after creating an entity.#spring.data.rest.return-body-on-update= true## Return a response body after updating an entity.#spring.data.rest.sort-param-name= name# Name of the URL query string parameter that indicates what direction to sort results. 创建实体类123456789101112@Entitypublic class Person &#123; @Id @GeneratedValue private int id; private String name; //@JsonIgnore 忽略该字段 private int age; public Person() &#123; super(); &#125;&#125; 实体类的Repository1234public interface PersonRepository extends JpaRepository&lt;Person, Integer&gt;&#123; @RestResource(path="byName", rel="byName", exported=true)//可指定访问路径, 和该方法是否公开 Person findByName(@Param("name") String name);&#125; HTTP访问（chrome安装postman插件）GET：查找http://localhost:8080/data/persons?page=1&amp;size=2&amp;sort=name,descpage:页数 size:每页的数量 sort:排序的字段和顺序POST：存储PUT：更新PUT：与put相似，但部分更新状态DELETE：删除]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>REST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu搭建个人网盘]]></title>
    <url>%2F2018%2F06%2F30%2FUbuntu%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%9B%98%2F</url>
    <content type="text"><![CDATA[常使用的两个云盘：百度云传视频尽竟然要开会员，坚果云免费的空间太小，所以决定使用Seafile搭建一个云盘 搭建环境 服务器：腾讯云Ubuntu 16.04.1 LTS 64 网盘Seafile：seafile-server_6.2.3_x86-64 安装步骤 安装mysql环境（要为root用户设置密码），如果已经安装过MySQL，跳过这个步骤 12sudo apt-get updatesudo apt-get install mysql-server 安装python依赖 1sudo apt-get install python2.7 python-setuptools python-imaging python-ldap python-mysqldb python-memcache python-urllib3 为Seafile创建一个用户,并切换为当前用户 12345sudo useradd -m -s /bin/bash seafile (用户名，可以自己更改)sudo passwd seafile （为该用户设置密码）enter unix password：XXXXX（提示输入服务器密码，即为seafile用户密码）su - seafilecd ~ 下载解压seafile（腾讯云提供的下载连接为32位的seafile，在安装配置后期会报错，下面的链接时更改之后没问题的） 123wget http://seafile-downloads.oss-cn-shanghai.aliyuncs.com/seafile-server_6.2.3_x86-64.tar.gztar -xzf seafile-server_*mv seafile-server-*/ seafile-server/ 配置seafile 12cd seafile-server*./setup-seafile-mysql.sh 注意： 存储位置 一定要填写当前账户有权限创建以及读写权限的位置，否则会配置失败，用用户名可创建新用户不使用root 启动seafile（如果配置阶段出错，启动的时候会报异常） 12./seafile.sh start ./seahub.sh start 在第一次启动的时候会要求配置管理员账户和密码 访问http://www.yourdomain.com:8000http://www.yourip.com:8000在第一次访问的时候，不知道为什么页面加载特别慢，ssh连接也没法连接到服务器，我把服务器重启了一下，然后再启动seafile服务就OK了123su - seafile（设置的用户名）cd seafile-server重复步骤 6 最后可以在seafile官网上下载，seafile各个平台的软件]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>云盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2018%2F06%2F11%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[交换排序：冒泡排序交换排序：通过以系列交换逆序元素进行排序的方法，包括冒泡排序和快速排序 冒泡排序 定义：冒泡排序是通过对 相邻元素 进行交换，逐步将待排序序列变成有序序列的过程 排序步骤：给一个数字序列升序排列：48，33，32，55，84，9，33，40 在第一趟冒泡排序中，从第一个记录开始，扫描整个序列，相邻数字为为降序则互换位置48，33，32，55，84，9，33，40 //48&gt;33，交换33，48，32，55，84，9，33，40 //48&gt;32，交换33，32，48，55，84，9，33，40 //48&lt;55, 不交换33，32，48，55，84，9，33，40 ······33，32，48，55，84，9，33，4033，32，48，55，9，84，33，4033，32，48，55，9，33，84，4033，32，48，55，9，33，40，84在第一次冒泡结束之后，将最大值84放置在末尾 第二次冒泡排序中，对前7数字个进行同样操作33，32，48，9，33，40，55，84在第二次冒泡结束之后，将第二大数55放置在倒数第二个位置 第三次序中，对前6字个进行同样操作33，32，48，9，33，40，55，84在第三结束之后，将第三大的数48放置在倒数第三个位置 由此可以得出，反复进行7次之后得到升序序列9, 32, 33, 33, 40, 48, 55, 84 算法实现 简单冒泡排序 123456789101112131415 /** * 简单冒泡排序 * @param arr */public static void bobble(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 2; i++) &#123; // 执行n - 1次 for (int j = 0; j &lt; arr.length - i - 1; j++) &#123; // 执行n - i次 if (arr[j] &gt; arr[j + 1]) &#123; int k = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = k; &#125; &#125; &#125;&#125; 带标志位的冒泡排序 12345678910111213141516171819202122 /** * 添加标志位的冒泡法 * 如果数组有序，减少循环次数 * @param arr */public static void bobble_one(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; boolean flag = true; for (int j = 0; j &lt; arr.length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int k = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = k; flag = false; &#125; &#125; if (flag) &#123; break; &#125; &#125;&#125; 鸡尾酒排序（两端同时冒泡） 12345678910111213141516171819202122232425262728293031 /** * 鸡尾酒冒泡 * 头尾同时冒泡 * @param arr */public static void bobble_two(int[] arr) &#123; for (int i = 0; i &lt; arr.length / 2; i++) &#123; boolean flag = true; for (int j = i; j &lt; arr.length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int k = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = k; flag = false; &#125; &#125; for (int j = arr.length - i - 2; j &gt; i; j--) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int k = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = k; flag = false; &#125; &#125; if (flag) &#123; break; &#125; &#125;&#125; 算法分析（只分析简单冒泡） 稳定性：稳定，从前向后比较，因为符合 arr[j] &gt; arr[j + 1]进行交换，所以大小相同的数字不会交换前后位置 时间复杂度：循环的次数为 ，所以移动的次数为 3n(n-1)/2，所以时间复杂度为 O(n^2) 空间复杂度：使用的辅助空间只有int变量 k，所以辅助空间为 O(1)]]></content>
      <categories>
        <category>Algorithm</category>
        <category>sort</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2018%2F06%2F07%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序 定义： 排序是计算机内经常进行的一种操作，其目的是将一组“无序”的记录序列调整为“有序”的记录序列 分类： 根据排序时候所占存储器不同，可分为内部排序和外部排序 内部排序：整个排序完全在内存中进行 外部排序：由于数量过大，内存无法容纳全部数据，排序需要借助外部存储设备完成 排序算法的评估 稳定性： 待排序的序列中有两个或两个以上相同的关键字，在排序前和排序后，关键字顺序未发生变化则排序方法是稳定的，反之则排序方法是不稳定的 证明一个排序方法是稳定的，要通过算法本身的步骤进行证明；证明排序方法是不稳定的，只需举出一个反例即可 例子：待排序序列{R1, R2,… , Ri, …, Rj, …, Rk …, Rn}中存在三个关键字Ri=Rj=Rk（下标i&lt;j&lt;k），排序之后若Ri, Rj, Rk前后顺序未发生改变则使用的排序方法是稳定的，反之则使用的排序方法是不稳定的 时间复杂度： 简单的说就是描述该算法的运行时间，肯定不可能每次去跑一遍程序比较，于是就有了用语句频度来估算的方式 第一步我们需要知道什么是语句频度T(n) ：程序运行过程中语句执行的次数 123456for (int i = 0; i &lt; n; i++) &#123; a += 1; //T1(n) = n for (int j = 0; j &lt; 2n; j++) &#123; sum += a; //T2(n) = n * 2n &#125;&#125; 在上面的例子中,语句频度 T(n) = T1(n) + T2(n) = 2 n^2 + n* 第二步计算辅助函数 f(n)：使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数，记为 T(n) = O(f(n))一般去除 T(n) = 2 n^2 + n 中的 低阶项和 首项系数可得到 f(n) = n^2* 最后 O(f(n)) = O(n^2) 获得渐进时间复杂度, 简称时间复杂度 常用的时间复杂度有：O(1) &lt; O(log n) &lt; 0(n) &lt; O(n log n) &lt; O(n^2) &lt; O(2^n) &lt; O(n!) 空间复杂度： 是对一个算法在运行过程中临时占用(辅助)存储空间大小的量度，记做S(n)=O(f(n)),与问题规模无关空间复杂度的计算与时间复杂度相似，时间复杂度使用的是语句频度，空间复杂度使用的是辅助空间的大小例如交换排序中常使用一个变量temp作为中间变量，空间复杂度为S(1) 1234567for (int j = 0; j &lt; n; j++) &#123; if (arr[i] &gt; arr[j]) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 一般而言，时间和空间复杂度是可以进行一定的相互转换， 递归时间复杂度：递归总次数 * 每次递归的次数空间复杂度：递归的深度 * 每次递归所需要的辅助空间]]></content>
      <categories>
        <category>Algorithm</category>
        <category>sort</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2F2018%2F06%2F07%2FHexo%2F</url>
    <content type="text"><![CDATA[Hexo 一直想试试用hexo来写博客，前不久有看到别人的，决定安装个试试 Hexo是什么？ &nbsp;&nbsp;&nbsp;&nbsp;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 ——官网 安装前提（至于安装和使用不做详解） Node.js 中文社区下载 Git 官网下载 Hexo安装（以Windows为例） 进入cmd命令行（路径无所谓）输入: npm install -g hexo-cli 初始化文件夹，下载需要的文件（特定的文件夹，最好是空的）： 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 启动服务器(必须在init的folder路径下)：hexo s 在浏览器中访问：http://localhost:4000]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Strat my blog]]></title>
    <url>%2F2018%2F05%2F28%2Farticle-title%2F</url>
    <content type="text"><![CDATA[Just want to do something…]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
